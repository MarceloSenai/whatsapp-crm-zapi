@inject HttpClient Http
@inject IJSRuntime JS
@implements IDisposable

@if (loading)
{
    <div class="flex items-center justify-center h-64">
        <div class="animate-spin w-8 h-8 border-2 border-whatsapp border-t-transparent rounded-full"></div>
    </div>
}
else if (pipeline != null)
{
    <div class="flex gap-4 overflow-x-auto p-4 h-full">
        @foreach (var stage in pipeline.Stages ?? [])
        {
            <KanbanColumn Stage="stage" />
        }
    </div>
}
else
{
    <div class="flex items-center justify-center h-64 text-gray-400">
        Nenhum pipeline configurado
    </div>
}

@code {
    private PipelineDto? pipeline;
    private bool loading = true;
    private DotNetObjectReference<KanbanBoard>? _dotNetRef;
    private bool _sortableInitialized;
    private int _initRetries = 0;
    private const int MaxInitRetries = 8;

    protected override async Task OnInitializedAsync()
    {
        await LoadPipeline();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_sortableInitialized && pipeline?.Stages != null && pipeline.Stages.Count > 0
            && _initRetries < MaxInitRetries)
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);
            try
            {
                await JS.InvokeVoidAsync("initSortable", _dotNetRef);
                _sortableInitialized = true;
                _initRetries = 0; // reset on success
            }
            catch (InvalidOperationException)
            {
                // Expected during SSR prerender — Blazor will call OnAfterRenderAsync again
                // after the interactive circuit connects, no action needed.
            }
            catch
            {
                // Script may not be ready yet (race with CDN) — schedule a retry render
                _initRetries++;
                _ = RetryInitAsync();
            }
        }
    }

    private async Task RetryInitAsync()
    {
        await Task.Delay(250);
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadPipeline()
    {
        loading = true;
        try
        {
            pipeline = await Http.GetFromJsonAsync<PipelineDto>("/api/pipeline");
        }
        catch { /* ignore */ }
        loading = false;
    }

    [JSInvokable]
    public async Task OnDealMoved(string dealId, string stageId)
    {
        try
        {
            await Http.PatchAsJsonAsync("/api/pipeline", new { dealId, stageId });
            await LoadPipeline();
            _sortableInitialized = false;
            await InvokeAsync(StateHasChanged);
        }
        catch { /* ignore */ }
    }

    public void Dispose()
    {
        try { JS.InvokeVoidAsync("destroySortable"); } catch { }
        _dotNetRef?.Dispose();
    }

    public class PipelineDto
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public List<StageDto>? Stages { get; set; }
    }

    public class StageDto
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public int Order { get; set; }
        public string Color { get; set; } = "";
        public List<DealDto>? Deals { get; set; }
    }

    public class DealDto
    {
        public string Id { get; set; } = "";
        public string Title { get; set; } = "";
        public double Value { get; set; }
        public string ContactId { get; set; } = "";
        public DealContact? Contact { get; set; }
    }

    public class DealContact
    {
        public string Name { get; set; } = "";
        public string Tags { get; set; } = "[]";
    }
}
